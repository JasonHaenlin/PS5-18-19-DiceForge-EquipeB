package fr.unice.polytech.si3.ps5.teamb.diceforge.game.exploit.card;

import java.util.EnumMap;
import java.util.Map;

import fr.unice.polytech.si3.ps5.teamb.diceforge.game.Inventory;
import fr.unice.polytech.si3.ps5.teamb.diceforge.game.Player;
import fr.unice.polytech.si3.ps5.teamb.diceforge.game.Resources;

public abstract class Card {

    private int moonStone;
    private int sunStone;
    private int victoryPoints;
    private Map<Resources, Integer> resInStock;

    // card owner is used to call back the player if an event occur
    protected Player cardOwner;

    private boolean played = false;

    public Card(int moonStone, int sunStone, int victoryPoints) {
        this.moonStone = moonStone;
        this.sunStone = sunStone;
        this.victoryPoints = victoryPoints;
        resInStock = new EnumMap<>(Resources.class);
    }

    public abstract String toString();

    /**
     * true if this card has an other action to do If the effect consist of putting
     * resources, you can use the Map `resInStock` and call `hasResourcesToStore()`
     * to retrieve it.
     * 
     * @param bot
     * @param inv
     */
    public void playImmEffect(Inventory inv) {
        // no effect
    }

    /**
     * check if this card has an effect
     */
    public boolean hasToken(Inventory inv) {
        // no token
        return false;
    }

    /**
     * check if this card has an effect
     */
    public boolean hasAfterEffect(Inventory inv) {
        // no effect
        return false;
    }

    /**
     * 
     * @param bot
     * @param inv
     */
    public boolean playAfterEffect(Inventory inv) {
        // no effect
        return false;
    }

    /**
     * ask the card if some resources need to be added in the player inventory after
     * the card has been played. When this methode is used the resources will be set
     * to 0
     * 
     * @return
     */
    public final Map<Resources, Integer> hasResourcesToStore() {
        Map<Resources, Integer> tmp = new EnumMap<>(Resources.class);
        tmp.putAll(resInStock);
        resInStock = new EnumMap<>(Resources.class);
        return tmp;
    }

    protected final void updateResources(Resources res, int n) {
        if (resInStock.containsKey(res)) {
            resInStock.replace(res, resInStock.get(res) + n);
        } else {
            resInStock.put(res, n);
        }
    }

    /**
     * @return the victoryPoints
     */
    public int getVictoryPoints() {
        return victoryPoints;
    }

    /**
     * @return the moonStone
     */
    public int getMoonStone() {
        return moonStone;
    }

    /**
     * @return the sunStone
     */
    public int getSunStone() {
        return sunStone;
    }

    /**
     * @param played the played to set
     */
    public final boolean hasBeenPlayed() {
        if (!this.played) {
            this.played = true;
            return false;
        }
        return true;
    }

    /**
     * @param cardOwner the cardOwner to set
     */
    public void setCardOwner(Player cardOwner) {
        this.cardOwner = cardOwner;
    }

}